
module.exports = function(User) {

/**
 * Find a related item by id for accessTokens.
 * @param {string} id User id
 * @param {string} fk Foreign key for accessTokens
 * @callback {Function} callback Callback function
 * @param {Error|string} err Error object
 * @param {AccessToken} result Result object
 */
User.prototypeFindByIdAccessTokens = function(id, fk, callback) {

  // Replace the code below with your implementation.
  // Please make sure the callback is invoked.
  process.nextTick(function() {
    var err = new Error('Not implemented');
    callback(err);
  });
  
}


/**
 * Delete a related item by id for accessTokens.
 * @param {string} id User id
 * @param {string} fk Foreign key for accessTokens
 * @callback {Function} callback Callback function
 * @param {Error|string} err Error object
 * @param {any} result Result object
 */
User.prototypeDestroyByIdAccessTokens = function(id, fk, callback) {

  // Replace the code below with your implementation.
  // Please make sure the callback is invoked.
  process.nextTick(function() {
    var err = new Error('Not implemented');
    callback(err);
  });
  
}


/**
 * Update a related item by id for accessTokens.
 * @param {string} id User id
 * @param {string} fk Foreign key for accessTokens
 * @param {AccessToken} data undefined
 * @callback {Function} callback Callback function
 * @param {Error|string} err Error object
 * @param {AccessToken} result Result object
 */
User.prototypeUpdateByIdAccessTokens = function(id, fk, data, callback) {

  // Replace the code below with your implementation.
  // Please make sure the callback is invoked.
  process.nextTick(function() {
    var err = new Error('Not implemented');
    callback(err);
  });
  
}


/**
 * Queries accessTokens of User.
 * @param {string} id User id
 * @param {string} filter undefined
 * @callback {Function} callback Callback function
 * @param {Error|string} err Error object
 * @param {AccessToken} result Result object
 */
User.prototypeGetAccessTokens = function(id, filter, callback) {

  // Replace the code below with your implementation.
  // Please make sure the callback is invoked.
  process.nextTick(function() {
    var err = new Error('Not implemented');
    callback(err);
  });
  
}


/**
 * Creates a new instance in accessTokens of this model.
 * @param {string} id User id
 * @param {AccessToken} data undefined
 * @callback {Function} callback Callback function
 * @param {Error|string} err Error object
 * @param {AccessToken} result Result object
 */
User.prototypeCreateAccessTokens = function(id, data, callback) {

  // Replace the code below with your implementation.
  // Please make sure the callback is invoked.
  process.nextTick(function() {
    var err = new Error('Not implemented');
    callback(err);
  });
  
}


/**
 * Deletes all accessTokens of this model.
 * @param {string} id User id
 * @callback {Function} callback Callback function
 * @param {Error|string} err Error object
 * @param {any} result Result object
 */
User.prototypeDeleteAccessTokens = function(id, callback) {

  // Replace the code below with your implementation.
  // Please make sure the callback is invoked.
  process.nextTick(function() {
    var err = new Error('Not implemented');
    callback(err);
  });
  
}


/**
 * Counts accessTokens of User.
 * @param {string} id User id
 * @param {string} where Criteria to match model instances
 * @callback {Function} callback Callback function
 * @param {Error|string} err Error object
 * @param {any} result Result object
 */
User.prototypeCountAccessTokens = function(id, where, callback) {

  // Replace the code below with your implementation.
  // Please make sure the callback is invoked.
  process.nextTick(function() {
    var err = new Error('Not implemented');
    callback(err);
  });
  
}


/**
 * Create a new instance of the model and persist it into the data source.
 * @param {User} data Model instance data
 * @callback {Function} callback Callback function
 * @param {Error|string} err Error object
 * @param {User} result Result object
 */
User.create = function(data, callback) {

  // Replace the code below with your implementation.
  // Please make sure the callback is invoked.
  process.nextTick(function() {
    var err = new Error('Not implemented');
    callback(err);
  });
  
}


/**
 * Patch an existing model instance or insert a new one into the data source.
 * @param {User} data Model instance data
 * @callback {Function} callback Callback function
 * @param {Error|string} err Error object
 * @param {User} result Result object
 */
User.patchOrCreate = function(data, callback) {

  // Replace the code below with your implementation.
  // Please make sure the callback is invoked.
  process.nextTick(function() {
    var err = new Error('Not implemented');
    callback(err);
  });
  
}


/**
 * Replace an existing model instance or insert a new one into the data source.
 * @param {User} data Model instance data
 * @callback {Function} callback Callback function
 * @param {Error|string} err Error object
 * @param {User} result Result object
 */
User.replaceOrCreatePutUsers = function(data, callback) {

  // Replace the code below with your implementation.
  // Please make sure the callback is invoked.
  process.nextTick(function() {
    var err = new Error('Not implemented');
    callback(err);
  });
  
}


/**
 * Find all instances of the model matched by filter from the data source.
 * @param {string} filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({"something":"value"})
 * @callback {Function} callback Callback function
 * @param {Error|string} err Error object
 * @param {User} result Result object
 */
User.find = function(filter, callback) {

  // Replace the code below with your implementation.
  // Please make sure the callback is invoked.
  process.nextTick(function() {
    var err = new Error('Not implemented');
    callback(err);
  });
  
}


/**
 * Replace an existing model instance or insert a new one into the data source.
 * @param {User} data Model instance data
 * @callback {Function} callback Callback function
 * @param {Error|string} err Error object
 * @param {User} result Result object
 */
User.replaceOrCreatePostUsersReplaceOrCreate = function(data, callback) {

  // Replace the code below with your implementation.
  // Please make sure the callback is invoked.
  process.nextTick(function() {
    var err = new Error('Not implemented');
    callback(err);
  });
  
}


/**
 * Update an existing model instance or insert a new one into the data source based on the where criteria.
 * @param {string} where Criteria to match model instances
 * @param {User} data An object of model property name/value pairs
 * @callback {Function} callback Callback function
 * @param {Error|string} err Error object
 * @param {User} result Result object
 */
User.upsertWithWhere = function(where, data, callback) {

  // Replace the code below with your implementation.
  // Please make sure the callback is invoked.
  process.nextTick(function() {
    var err = new Error('Not implemented');
    callback(err);
  });
  
}


/**
 * Check whether a model instance exists in the data source.
 * @param {string} id Model id
 * @callback {Function} callback Callback function
 * @param {Error|string} err Error object
 * @param {any} result Result object
 */
User.existsGetUsersIdExists = function(id, callback) {

  // Replace the code below with your implementation.
  // Please make sure the callback is invoked.
  process.nextTick(function() {
    var err = new Error('Not implemented');
    callback(err);
  });
  
}


/**
 * Check whether a model instance exists in the data source.
 * @param {string} id Model id
 * @callback {Function} callback Callback function
 * @param {Error|string} err Error object
 * @param {any} result Result object
 */
User.existsHeadUsersId = function(id, callback) {

  // Replace the code below with your implementation.
  // Please make sure the callback is invoked.
  process.nextTick(function() {
    var err = new Error('Not implemented');
    callback(err);
  });
  
}


/**
 * Find a model instance by {{id}} from the data source.
 * @param {string} id Model id
 * @param {string} filter Filter defining fields and include - must be a JSON-encoded string ({"something":"value"})
 * @callback {Function} callback Callback function
 * @param {Error|string} err Error object
 * @param {User} result Result object
 */
User.findById = function(id, filter, callback) {

  // Replace the code below with your implementation.
  // Please make sure the callback is invoked.
  process.nextTick(function() {
    var err = new Error('Not implemented');
    callback(err);
  });
  
}


/**
 * Replace attributes for a model instance and persist it into the data source.
 * @param {string} id Model id
 * @param {User} data Model instance data
 * @callback {Function} callback Callback function
 * @param {Error|string} err Error object
 * @param {User} result Result object
 */
User.replaceByIdPutUsersId = function(id, data, callback) {

  // Replace the code below with your implementation.
  // Please make sure the callback is invoked.
  process.nextTick(function() {
    var err = new Error('Not implemented');
    callback(err);
  });
  
}


/**
 * Delete a model instance by {{id}} from the data source.
 * @param {string} id Model id
 * @callback {Function} callback Callback function
 * @param {Error|string} err Error object
 * @param {any} result Result object
 */
User.deleteById = function(id, callback) {

  // Replace the code below with your implementation.
  // Please make sure the callback is invoked.
  process.nextTick(function() {
    var err = new Error('Not implemented');
    callback(err);
  });
  
}


/**
 * Patch attributes for a model instance and persist it into the data source.
 * @param {string} id User id
 * @param {User} data An object of model property name/value pairs
 * @callback {Function} callback Callback function
 * @param {Error|string} err Error object
 * @param {User} result Result object
 */
User.prototypePatchAttributes = function(id, data, callback) {

  // Replace the code below with your implementation.
  // Please make sure the callback is invoked.
  process.nextTick(function() {
    var err = new Error('Not implemented');
    callback(err);
  });
  
}


/**
 * Replace attributes for a model instance and persist it into the data source.
 * @param {string} id Model id
 * @param {User} data Model instance data
 * @callback {Function} callback Callback function
 * @param {Error|string} err Error object
 * @param {User} result Result object
 */
User.replaceByIdPostUsersIdReplace = function(id, data, callback) {

  // Replace the code below with your implementation.
  // Please make sure the callback is invoked.
  process.nextTick(function() {
    var err = new Error('Not implemented');
    callback(err);
  });
  
}


/**
 * Find first instance of the model matched by filter from the data source.
 * @param {string} filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({"something":"value"})
 * @callback {Function} callback Callback function
 * @param {Error|string} err Error object
 * @param {User} result Result object
 */
User.findOne = function(filter, callback) {

  // Replace the code below with your implementation.
  // Please make sure the callback is invoked.
  process.nextTick(function() {
    var err = new Error('Not implemented');
    callback(err);
  });
  
}


/**
 * Update instances of the model matched by {{where}} from the data source.
 * @param {string} where Criteria to match model instances
 * @param {User} data An object of model property name/value pairs
 * @callback {Function} callback Callback function
 * @param {Error|string} err Error object
 * @param {any} result Result object
 */
User.updateAll = function(where, data, callback) {

  // Replace the code below with your implementation.
  // Please make sure the callback is invoked.
  process.nextTick(function() {
    var err = new Error('Not implemented');
    callback(err);
  });
  
}


/**
 * Count instances of the model matched by where from the data source.
 * @param {string} where Criteria to match model instances
 * @callback {Function} callback Callback function
 * @param {Error|string} err Error object
 * @param {any} result Result object
 */
User.count = function(where, callback) {

  // Replace the code below with your implementation.
  // Please make sure the callback is invoked.
  process.nextTick(function() {
    var err = new Error('Not implemented');
    callback(err);
  });
  
}


/**
 * Create a change stream.
 * @param {string} options undefined
 * @callback {Function} callback Callback function
 * @param {Error|string} err Error object
 * @param {any} result Result object
 */
User.createChangeStreamPostUsersChangeStream = function(options, callback) {

  // Replace the code below with your implementation.
  // Please make sure the callback is invoked.
  process.nextTick(function() {
    var err = new Error('Not implemented');
    callback(err);
  });
  
}


/**
 * Create a change stream.
 * @param {string} options undefined
 * @callback {Function} callback Callback function
 * @param {Error|string} err Error object
 * @param {any} result Result object
 */
User.createChangeStreamGetUsersChangeStream = function(options, callback) {

  // Replace the code below with your implementation.
  // Please make sure the callback is invoked.
  process.nextTick(function() {
    var err = new Error('Not implemented');
    callback(err);
  });
  
}


/**
 * Login a user with username/email and password.
 * @param {any} credentials undefined
 * @param {string} include Related objects to include in the response. See the description of return value for more details.
 * @callback {Function} callback Callback function
 * @param {Error|string} err Error object
 * @param {any} result Result object
 */
User.login = function(credentials, include, callback) {

  // Replace the code below with your implementation.
  // Please make sure the callback is invoked.
  process.nextTick(function() {
    var err = new Error('Not implemented');
    callback(err);
  });
  
}


/**
 * Logout a user with access token.

 * @callback {Function} callback Callback function
 * @param {Error|string} err Error object
 * @param {any} result Result object
 */
User.logout = function(callback) {

  // Replace the code below with your implementation.
  // Please make sure the callback is invoked.
  process.nextTick(function() {
    var err = new Error('Not implemented');
    callback(err);
  });
  
}


/**
 * Trigger user's identity verification with configured verifyOptions
 * @param {string} id User id
 * @callback {Function} callback Callback function
 * @param {Error|string} err Error object
 * @param {any} result Result object
 */
User.prototypeVerify = function(id, callback) {

  // Replace the code below with your implementation.
  // Please make sure the callback is invoked.
  process.nextTick(function() {
    var err = new Error('Not implemented');
    callback(err);
  });
  
}


/**
 * Confirm a user registration with identity verification token.
 * @param {string} uid undefined
 * @param {string} token undefined
 * @param {string} redirect undefined
 * @callback {Function} callback Callback function
 * @param {Error|string} err Error object
 * @param {any} result Result object
 */
User.confirm = function(uid, token, redirect, callback) {

  // Replace the code below with your implementation.
  // Please make sure the callback is invoked.
  process.nextTick(function() {
    var err = new Error('Not implemented');
    callback(err);
  });
  
}


/**
 * Reset password for a user with email.
 * @param {any} options undefined
 * @callback {Function} callback Callback function
 * @param {Error|string} err Error object
 * @param {any} result Result object
 */
User.resetPassword = function(options, callback) {

  // Replace the code below with your implementation.
  // Please make sure the callback is invoked.
  process.nextTick(function() {
    var err = new Error('Not implemented');
    callback(err);
  });
  
}


/**
 * Change a user's password.
 * @param {string} oldPassword undefined
 * @param {string} newPassword undefined
 * @callback {Function} callback Callback function
 * @param {Error|string} err Error object
 * @param {any} result Result object
 */
User.changePassword = function(oldPassword, newPassword, callback) {

  // Replace the code below with your implementation.
  // Please make sure the callback is invoked.
  process.nextTick(function() {
    var err = new Error('Not implemented');
    callback(err);
  });
  
}


/**
 * Reset user's password via a password-reset token.
 * @param {string} newPassword undefined
 * @callback {Function} callback Callback function
 * @param {Error|string} err Error object
 * @param {any} result Result object
 */
User.setPassword = function(newPassword, callback) {

  // Replace the code below with your implementation.
  // Please make sure the callback is invoked.
  process.nextTick(function() {
    var err = new Error('Not implemented');
    callback(err);
  });
  
}




User.remoteMethod('prototypeFindByIdAccessTokens',
  { isStatic: true,
  accepts: 
   [ { arg: 'id',
       type: 'string',
       description: 'User id',
       required: true,
       http: { source: 'path' } },
     { arg: 'fk',
       type: 'string',
       description: 'Foreign key for accessTokens',
       required: true,
       http: { source: 'path' } } ],
  returns: 
   [ { description: 'Request was successful',
       type: 'AccessToken',
       arg: 'data',
       root: true } ],
  http: { verb: 'get', path: '/Users/:id/accessTokens/:fk' },
  description: undefined }
);

User.remoteMethod('prototypeDestroyByIdAccessTokens',
  { isStatic: true,
  accepts: 
   [ { arg: 'id',
       type: 'string',
       description: 'User id',
       required: true,
       http: { source: 'path' } },
     { arg: 'fk',
       type: 'string',
       description: 'Foreign key for accessTokens',
       required: true,
       http: { source: 'path' } } ],
  returns: [],
  http: { verb: 'delete', path: '/Users/:id/accessTokens/:fk' },
  description: undefined }
);

User.remoteMethod('prototypeUpdateByIdAccessTokens',
  { isStatic: true,
  accepts: 
   [ { arg: 'id',
       type: 'string',
       description: 'User id',
       required: true,
       http: { source: 'path' } },
     { arg: 'fk',
       type: 'string',
       description: 'Foreign key for accessTokens',
       required: true,
       http: { source: 'path' } },
     { arg: 'data',
       type: 'AccessToken',
       description: undefined,
       required: false,
       http: { source: 'body' } } ],
  returns: 
   [ { description: 'Request was successful',
       type: 'AccessToken',
       arg: 'data',
       root: true } ],
  http: { verb: 'put', path: '/Users/:id/accessTokens/:fk' },
  description: undefined }
);

User.remoteMethod('prototypeGetAccessTokens',
  { isStatic: true,
  accepts: 
   [ { arg: 'id',
       type: 'string',
       description: 'User id',
       required: true,
       http: { source: 'path' } },
     { arg: 'filter',
       type: 'string',
       description: undefined,
       required: false,
       http: { source: 'query' } } ],
  returns: 
   [ { description: 'Request was successful',
       type: [ 'AccessToken' ],
       arg: 'data',
       root: true } ],
  http: { verb: 'get', path: '/Users/:id/accessTokens' },
  description: undefined }
);

User.remoteMethod('prototypeCreateAccessTokens',
  { isStatic: true,
  accepts: 
   [ { arg: 'id',
       type: 'string',
       description: 'User id',
       required: true,
       http: { source: 'path' } },
     { arg: 'data',
       type: 'AccessToken',
       description: undefined,
       required: false,
       http: { source: 'body' } } ],
  returns: 
   [ { description: 'Request was successful',
       type: 'AccessToken',
       arg: 'data',
       root: true } ],
  http: { verb: 'post', path: '/Users/:id/accessTokens' },
  description: undefined }
);

User.remoteMethod('prototypeDeleteAccessTokens',
  { isStatic: true,
  accepts: 
   [ { arg: 'id',
       type: 'string',
       description: 'User id',
       required: true,
       http: { source: 'path' } } ],
  returns: [],
  http: { verb: 'delete', path: '/Users/:id/accessTokens' },
  description: undefined }
);

User.remoteMethod('prototypeCountAccessTokens',
  { isStatic: true,
  accepts: 
   [ { arg: 'id',
       type: 'string',
       description: 'User id',
       required: true,
       http: { source: 'path' } },
     { arg: 'where',
       type: 'string',
       description: 'Criteria to match model instances',
       required: false,
       http: { source: 'query' } } ],
  returns: [],
  http: { verb: 'get', path: '/Users/:id/accessTokens/count' },
  description: undefined }
);

User.remoteMethod('create',
  { isStatic: true,
  accepts: 
   [ { arg: 'data',
       type: 'User',
       description: 'Model instance data',
       required: false,
       http: { source: 'body' } } ],
  returns: 
   [ { description: 'Request was successful',
       type: 'User',
       arg: 'data',
       root: true } ],
  http: { verb: 'post', path: '/Users' },
  description: undefined }
);

User.remoteMethod('patchOrCreate',
  { isStatic: true,
  accepts: 
   [ { arg: 'data',
       type: 'User',
       description: 'Model instance data',
       required: false,
       http: { source: 'body' } } ],
  returns: 
   [ { description: 'Request was successful',
       type: 'User',
       arg: 'data',
       root: true } ],
  http: { verb: 'patch', path: '/Users' },
  description: undefined }
);

User.remoteMethod('replaceOrCreatePutUsers',
  { isStatic: true,
  accepts: 
   [ { arg: 'data',
       type: 'User',
       description: 'Model instance data',
       required: false,
       http: { source: 'body' } } ],
  returns: 
   [ { description: 'Request was successful',
       type: 'User',
       arg: 'data',
       root: true } ],
  http: { verb: 'put', path: '/Users' },
  description: undefined }
);

User.remoteMethod('find',
  { isStatic: true,
  accepts: 
   [ { arg: 'filter',
       type: 'string',
       description: 'Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({"something":"value"})',
       required: false,
       http: { source: 'query' } } ],
  returns: 
   [ { description: 'Request was successful',
       type: [ 'User' ],
       arg: 'data',
       root: true } ],
  http: { verb: 'get', path: '/Users' },
  description: undefined }
);

User.remoteMethod('replaceOrCreatePostUsersReplaceOrCreate',
  { isStatic: true,
  accepts: 
   [ { arg: 'data',
       type: 'User',
       description: 'Model instance data',
       required: false,
       http: { source: 'body' } } ],
  returns: 
   [ { description: 'Request was successful',
       type: 'User',
       arg: 'data',
       root: true } ],
  http: { verb: 'post', path: '/Users/replaceOrCreate' },
  description: undefined }
);

User.remoteMethod('upsertWithWhere',
  { isStatic: true,
  accepts: 
   [ { arg: 'where',
       type: 'string',
       description: 'Criteria to match model instances',
       required: false,
       http: { source: 'query' } },
     { arg: 'data',
       type: 'User',
       description: 'An object of model property name/value pairs',
       required: false,
       http: { source: 'body' } } ],
  returns: 
   [ { description: 'Request was successful',
       type: 'User',
       arg: 'data',
       root: true } ],
  http: { verb: 'post', path: '/Users/upsertWithWhere' },
  description: undefined }
);

User.remoteMethod('existsGetUsersIdExists',
  { isStatic: true,
  accepts: 
   [ { arg: 'id',
       type: 'string',
       description: 'Model id',
       required: true,
       http: { source: 'path' } } ],
  returns: [],
  http: { verb: 'get', path: '/Users/:id/exists' },
  description: undefined }
);

User.remoteMethod('existsHeadUsersId',
  { isStatic: true,
  accepts: 
   [ { arg: 'id',
       type: 'string',
       description: 'Model id',
       required: true,
       http: { source: 'path' } } ],
  returns: [],
  http: { verb: 'head', path: '/Users/:id' },
  description: undefined }
);

User.remoteMethod('findById',
  { isStatic: true,
  accepts: 
   [ { arg: 'id',
       type: 'string',
       description: 'Model id',
       required: true,
       http: { source: 'path' } },
     { arg: 'filter',
       type: 'string',
       description: 'Filter defining fields and include - must be a JSON-encoded string ({"something":"value"})',
       required: false,
       http: { source: 'query' } } ],
  returns: 
   [ { description: 'Request was successful',
       type: 'User',
       arg: 'data',
       root: true } ],
  http: { verb: 'get', path: '/Users/:id' },
  description: undefined }
);

User.remoteMethod('replaceByIdPutUsersId',
  { isStatic: true,
  accepts: 
   [ { arg: 'id',
       type: 'string',
       description: 'Model id',
       required: true,
       http: { source: 'path' } },
     { arg: 'data',
       type: 'User',
       description: 'Model instance data',
       required: false,
       http: { source: 'body' } } ],
  returns: 
   [ { description: 'Request was successful',
       type: 'User',
       arg: 'data',
       root: true } ],
  http: { verb: 'put', path: '/Users/:id' },
  description: undefined }
);

User.remoteMethod('deleteById',
  { isStatic: true,
  accepts: 
   [ { arg: 'id',
       type: 'string',
       description: 'Model id',
       required: true,
       http: { source: 'path' } } ],
  returns: [],
  http: { verb: 'delete', path: '/Users/:id' },
  description: undefined }
);

User.remoteMethod('prototypePatchAttributes',
  { isStatic: true,
  accepts: 
   [ { arg: 'id',
       type: 'string',
       description: 'User id',
       required: true,
       http: { source: 'path' } },
     { arg: 'data',
       type: 'User',
       description: 'An object of model property name/value pairs',
       required: false,
       http: { source: 'body' } } ],
  returns: 
   [ { description: 'Request was successful',
       type: 'User',
       arg: 'data',
       root: true } ],
  http: { verb: 'patch', path: '/Users/:id' },
  description: undefined }
);

User.remoteMethod('replaceByIdPostUsersIdReplace',
  { isStatic: true,
  accepts: 
   [ { arg: 'id',
       type: 'string',
       description: 'Model id',
       required: true,
       http: { source: 'path' } },
     { arg: 'data',
       type: 'User',
       description: 'Model instance data',
       required: false,
       http: { source: 'body' } } ],
  returns: 
   [ { description: 'Request was successful',
       type: 'User',
       arg: 'data',
       root: true } ],
  http: { verb: 'post', path: '/Users/:id/replace' },
  description: undefined }
);

User.remoteMethod('findOne',
  { isStatic: true,
  accepts: 
   [ { arg: 'filter',
       type: 'string',
       description: 'Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string ({"something":"value"})',
       required: false,
       http: { source: 'query' } } ],
  returns: 
   [ { description: 'Request was successful',
       type: 'User',
       arg: 'data',
       root: true } ],
  http: { verb: 'get', path: '/Users/findOne' },
  description: undefined }
);

User.remoteMethod('updateAll',
  { isStatic: true,
  accepts: 
   [ { arg: 'where',
       type: 'string',
       description: 'Criteria to match model instances',
       required: false,
       http: { source: 'query' } },
     { arg: 'data',
       type: 'User',
       description: 'An object of model property name/value pairs',
       required: false,
       http: { source: 'body' } } ],
  returns: [],
  http: { verb: 'post', path: '/Users/update' },
  description: undefined }
);

User.remoteMethod('count',
  { isStatic: true,
  accepts: 
   [ { arg: 'where',
       type: 'string',
       description: 'Criteria to match model instances',
       required: false,
       http: { source: 'query' } } ],
  returns: [],
  http: { verb: 'get', path: '/Users/count' },
  description: undefined }
);

User.remoteMethod('createChangeStreamPostUsersChangeStream',
  { isStatic: true,
  accepts: 
   [ { arg: 'options',
       type: 'string',
       description: undefined,
       required: false,
       http: { source: 'formData' } } ],
  returns: [],
  http: { verb: 'post', path: '/Users/change-stream' },
  description: undefined }
);

User.remoteMethod('createChangeStreamGetUsersChangeStream',
  { isStatic: true,
  accepts: 
   [ { arg: 'options',
       type: 'string',
       description: undefined,
       required: false,
       http: { source: 'query' } } ],
  returns: [],
  http: { verb: 'get', path: '/Users/change-stream' },
  description: undefined }
);

User.remoteMethod('login',
  { isStatic: true,
  accepts: 
   [ { arg: 'credentials',
       type: 'any',
       description: undefined,
       required: true,
       http: { source: 'body' } },
     { arg: 'include',
       type: 'string',
       description: 'Related objects to include in the response. See the description of return value for more details.',
       required: false,
       http: { source: 'query' } } ],
  returns: [],
  http: { verb: 'post', path: '/Users/login' },
  description: undefined }
);

User.remoteMethod('logout',
  { isStatic: true,
  accepts: [],
  returns: [],
  http: { verb: 'post', path: '/Users/logout' },
  description: undefined }
);

User.remoteMethod('prototypeVerify',
  { isStatic: true,
  accepts: 
   [ { arg: 'id',
       type: 'string',
       description: 'User id',
       required: true,
       http: { source: 'path' } } ],
  returns: [],
  http: { verb: 'post', path: '/Users/:id/verify' },
  description: undefined }
);

User.remoteMethod('confirm',
  { isStatic: true,
  accepts: 
   [ { arg: 'uid',
       type: 'string',
       description: undefined,
       required: true,
       http: { source: 'query' } },
     { arg: 'token',
       type: 'string',
       description: undefined,
       required: true,
       http: { source: 'query' } },
     { arg: 'redirect',
       type: 'string',
       description: undefined,
       required: false,
       http: { source: 'query' } } ],
  returns: [],
  http: { verb: 'get', path: '/Users/confirm' },
  description: undefined }
);

User.remoteMethod('resetPassword',
  { isStatic: true,
  accepts: 
   [ { arg: 'options',
       type: 'any',
       description: undefined,
       required: true,
       http: { source: 'body' } } ],
  returns: [],
  http: { verb: 'post', path: '/Users/reset' },
  description: undefined }
);

User.remoteMethod('changePassword',
  { isStatic: true,
  accepts: 
   [ { arg: 'oldPassword',
       type: 'string',
       description: undefined,
       required: true,
       http: { source: 'formData' } },
     { arg: 'newPassword',
       type: 'string',
       description: undefined,
       required: true,
       http: { source: 'formData' } } ],
  returns: [],
  http: { verb: 'post', path: '/Users/change-password' },
  description: undefined }
);

User.remoteMethod('setPassword',
  { isStatic: true,
  accepts: 
   [ { arg: 'newPassword',
       type: 'string',
       description: undefined,
       required: true,
       http: { source: 'formData' } } ],
  returns: [],
  http: { verb: 'post', path: '/Users/reset-password' },
  description: undefined }
);

}
